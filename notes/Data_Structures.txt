Data Structures

They all have one thing in common is that we must include the appropriate header file to use them.

Vector:
	
Store element like same data. 
It can dynamically resize. 
Adding or removing element can be done at the end.
Element can be access through the index.

Syntax:
vector<type> vectorname={};
vectorname.front();
vectorname.back();
vectorname.at(index_number);
vectorname.push_back("value");
vectorname.pop_back();
vectorname.size();
vectorname.empty();


List:

Stores the element in sequence.
Adding element can be done from both the end(beginning and end).
Not accessible by the index values.

Syntax:
list<type> listname={};
listname.front();
listname.back();
listname.push_front("value");
listname.push_back("value");
listname.pop_front();
listname.pop_back();
listname.size();
listname.empty();


Stack:

Store element in a LIFO(Last In First Out) order.
Element can be add or removed from the end.
Not accessible by the index.


Syntax:
stack<type> stackname={};
stackname.push(value);
stackname.top();
stackname.pop();
stackname.size();
stackname.empty();


Queue:

Store the element in a FIFO(First In First Out) order.
Element can be accessible from the front for both add or remove.
Not accessible by the index.
 
queue<type> queueName={};
queueName.push(value);
queueName.front();
queueName.back();
queueName.pop();
queueName.size();
queueName.empty();


Deque:

Stores element in a double ended queue.
Element can be access from the front and end.
Element can be accessed using the index.


Syntax:
deque<type> dequename={};
dequename[index];
dequename.front();
dequename.back();
dequename.at(index);
dequename[index]=change value;
dequename.push_front(value);
dequename.push_back(value);
dequename.pop_front();
dequename.pop_back();
dequename.size();
dequename.empty();




Set:

Store only the unique element.
Not accessible by the index.


Syntax:
set<type> setname={};
set<type, greater<type>> set name={};
setname.insert(value);
setname.erase(value);
setname.clear();--->clear entire set.
setname.size();
setname.empty();


Map:

Store the elements in key/value pair.
Values can be accessed by keys  not by the index.

Syntax:
map<keytype, valuetype> mapname={{key, value}}; or mapname[key]=value; or mapname.insert({key, value});
map<keytype, valuetype, greater<key type/value type>> mapname={{key, value}};
mapname[key];
mapname.at(key name);
mapname.erase(key);
mapname.clear();
mapname.empty();

loop:

for (auto person:people){
	cout<<person.first<<person.second<"\n";
}














